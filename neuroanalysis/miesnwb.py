from __future__ import print_function, division
import sys
from datetime import datetime
from collections import OrderedDict
import numpy as np
import h5py

from .data import Dataset, SyncRecording, PatchClampRecording, TSeries
from .test_pulse import PatchClampTestPulse
from . import stimuli


class MiesNwb(Dataset):
    """Class for accessing data from a MIES-generated NWB file.
    """
    def __init__(self, filename):
        Dataset.__init__(self)
        self.filename = filename
        self._hdf = None
        self._sweeps = None
        self._timeseries = None
        self._groups = None
        self._notebook = None
        self.open()
        
    @property
    def hdf(self):
        if self._hdf is None:
            self.open()
        return self._hdf

    def notebook(self):
        """Return compiled data from the lab notebook.

        The format is a dict like ``{sweep_number: [ch1, ch2, ...]}`` that contains one key:value
        pair per sweep. Each value is a list containing one metadata dict for each channel in the
        sweep. For example::

            nwb.notebook()[sweep_id][channel_id][metadata_key]
        """
        if self._notebook is None:
            # collect all lab notebook entries
            sweep_entries = OrderedDict()
            tp_entries = []
            device = list(self.hdf['general/devices'].keys())[0].split('_',1)[-1]
            nb_keys = self.hdf['general']['labnotebook'][device]['numericalKeys'][0]
            nb_fields = OrderedDict([(k, i) for i,k in enumerate(nb_keys)])

            # convert notebook to array here, otherwise we incur the decompression cost for the entire
            # dataset every time we try to access part of it. 
            nb = np.array(self.hdf['general']['labnotebook'][device]['numericalValues'])

            # EntrySourceType field is needed to distinguish between records created by TP vs sweep
            entry_source_type_index = nb_fields.get('EntrySourceType', None)
            
            nb_iter = iter(range(nb.shape[0]))  # so we can skip multiple rows from within the loop
            for i in nb_iter:
                rec = nb[i]
                sweep_num = rec[0,0]

                is_tp_record = False
                is_sweep_record = False

                # ignore records that were generated by test pulse
                # (note: entrySourceType is nan if an older pxp is re-exported to nwb using newer MIES)
                if entry_source_type_index is not None and not np.isnan(rec[entry_source_type_index][0]):
                    if rec[entry_source_type_index][0] == 0:
                        is_sweep_record = True
                    else:
                        is_tp_record = True
                elif i < nb.shape[0] - 1:
                    # Older files may be missing EntrySourceType. In this case, we can identify TP blocks
                    # as two records containing a "TP Peak Resistance" value in the first record followed
                    # by a "TP Pulse Duration" value in the second record.
                    tp_peak = rec[nb_fields['TP Peak Resistance']]
                    if any(np.isfinite(tp_peak)):
                        tp_dur = nb[i+1][nb_fields['TP Pulse Duration']]
                        if any(np.isfinite(tp_dur)):
                            next(nb_iter)
                            is_tp_record = True
                    if not is_tp_record:
                        is_sweep_record = np.isfinite(sweep_num)

                if is_tp_record:
                    rec = np.array(rec)
                    next(nb_iter)
                    rec2 = np.array(nb[i+1])
                    mask = ~np.isnan(rec2)
                    rec[mask] = rec2[mask]
                    tp_entries.append(rec)

                elif is_sweep_record:
                    sweep_num = int(sweep_num)
                    # each sweep gets multiple nb records; for each field we use the last non-nan value in any record
                    if sweep_num not in sweep_entries:
                        sweep_entries[sweep_num] = np.array(rec)
                    else:
                        mask = ~np.isnan(rec)
                        sweep_entries[sweep_num][mask] = rec[mask]

            for swid, entry in sweep_entries.items():
                # last column is "global"; applies to all channels
                mask = ~np.isnan(entry[:,8])
                entry[mask] = entry[:,8:9][mask]
    
                # first 4 fields of first column apply to all channels
                entry[:4] = entry[:4, 0:1]

                # async AD fields (notably used to record temperature) appear
                # only in column 0, but might move to column 8 later? Since these
                # are not channel-specific, we'll copy them to all channels
                for i,k in enumerate(nb_keys):
                    if not k.startswith('Async AD '):
                        continue
                    entry[i] = entry[i, 0]

                # convert to list-o-dicts
                meta = []
                for i in range(entry.shape[1]):
                    tm = entry[:, i]
                    meta.append(OrderedDict([(nb_keys[j], (None if np.isnan(tm[j]) else tm[j])) for j in range(len(nb_keys))]))
                sweep_entries[swid] = meta

            # Load textual keys in a similar way 
            text_nb_keys = self.hdf['general']['labnotebook'][device]['textualKeys'][0]
            text_nb_fields = OrderedDict([(k, i) for i,k in enumerate(text_nb_keys)])
            text_nb = np.array(self.hdf['general']['labnotebook'][device]['textualValues'])
            entry_source_type_index = text_nb_fields.get('EntrySourceType', None)

            for rec in text_nb:
                if entry_source_type_index is None:
                    # older nwb files lack EntrySourceType; fake it for now
                    source_type = 0
                else:
                    try:
                        source_type = int(rec[entry_source_type_index, 0])
                    except ValueError:
                        # No entry source type recorded here; skip for now.
                        continue

                if source_type != 0:
                    # Select only sweep records for now.
                    continue

                try:
                    sweep_id = int(rec[0,0])
                except ValueError:
                    # Not sure how to handle records with no sweep ID; skip for now.
                    continue
                sweep_entry = sweep_entries[sweep_id]

                for k,i in text_nb_fields.items():                    
                    for j, val in enumerate(rec[i, :-1]):
                        if k in sweep_entry[j]:
                            # already have a value here; don't overwrite.
                            continue

                        if val == '':
                            # take value from last column if this one is empty
                            val == rec[i, -1]
                        if val == '':
                            # no value here; skip.
                            continue
                        
                        sweep_entry[j][k] = val

            self._notebook = sweep_entries
            self._tp_notebook = tp_entries
            self._notebook_keys = nb_fields
            self._tp_entries = None
        return self._notebook

    @property
    def contents(self):
        """A list of all sweeps in this file.
        """
        if self._sweeps is None:
            # sort all timeseries groups into sweeps / channels
            self._timeseries = {}
            for ts_name, ts in self.hdf['acquisition/timeseries'].items():
                src = dict([field.split('=') for field in ts.attrs['source'].split(';')])
                sweep = int(src['Sweep'])
                ad_chan = int(src['AD'])
                src['hdf_group_name'] = 'acquisition/timeseries/' + ts_name
                self._timeseries.setdefault(sweep, {})[ad_chan] = src
            
            sweep_ids = sorted(list(self._timeseries.keys()))
            self._sweeps = []
            for sweep_id in sweep_ids:
                srec = self.create_sync_recording(int(sweep_id))
                self._sweeps.append(srec)
        return self._sweeps
    
    def create_sync_recording(self, sweep_id):
        return MiesSyncRecording(self, sweep_id)

    def close(self):
        self.hdf.close()
        self._hdf = None

    def open(self):
        if self._hdf is not None:
            return
        try:
            self._hdf = h5py.File(self.filename, 'r')
        except Exception:
            print("Error opening: %s" % self.filename)
            raise

    def __enter__(self):
        self.open()
        return self
    
    def __exit__(self, *args):
        self.close()

    @staticmethod
    def pack_sweep_data(sweeps):
        """Return a single array containing all data from a list of sweeps.
        
        The array shape is (sweeps, channels, samples, 2), where the final axis
        contains recorded data at index 0 and the stimulus at index 1.

        All sweeps must have the same length and number of channels.
        """
        sweeps = [s.data() for s in sweeps]
        data = np.empty((len(sweeps),) + sweeps[0].shape, dtype=sweeps[0].dtype)
        for i in range(len(sweeps)):
            data[i] = sweeps[i]
        return data

    @staticmethod
    def igorpro_date(timestamp):
        """Convert an IgorPro timestamp (seconds since 1904-01-01) to a datetime
        object.
        """
        dt = datetime(1970,1,1) - datetime(1904,1,1)
        return datetime.utcfromtimestamp(timestamp) - dt

    @property
    def children(self):
        return self.contents
    
    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__, self.filename)

    def __getstate__(self):
        state = self.__dict__.copy()
        # don't try to pickle hdf objects
        state['_hdf'] = None
        return state

    def test_pulse_entries(self):
        if self._tp_entries is None:
            self._tp_entries = []
            fields = ['TP Baseline Vm', 'TP Baseline pA', 'TP Peak Resistance', 'TP Steady State Resistance']
            stim_fields = ['TP Baseline Fraction', 'TP Amplitude VC', 'TP Amplitude IC', 'TP Pulse Duration']
            for rec in self._tp_notebook:
                entry = {'timestamp': MiesNwb.igorpro_date(rec[1, 0])}
                for f in fields:
                    i = self._notebook_keys[f]
                    entry[f] = rec[i, :8]
                entry['stim'] = {f:rec[self._notebook_keys[f], 8] for f in stim_fields}
                self._tp_entries.append(entry)
        return self._tp_entries


class MiesTSeries(TSeries):
    def __init__(self, recording, chan):
        start = recording._meta['start_time']
        
        # Note: this is also available in meta()['Minimum Sampling interval'],
        # but that key is missing in some older NWB files.
        dt = recording.primary_hdf.attrs['IGORWaveScaling'][1,0] / 1000.
        TSeries.__init__(self, recording=recording, channel_id=chan, dt=dt, start_time=start)
    
    @property
    def data(self):
        if self._data is None:
            rec = self.recording
            chan = self.channel_id
            if chan == 'primary':
                scale = 1e-12 if rec.clamp_mode == 'vc' else 1e-3
                self._data = np.array(rec.primary_hdf) * scale
            elif chan == 'command':
                scale = 1e-3 if rec.clamp_mode == 'vc' else 1e-12
                # command values are stored _without_ holding, so we add
                # that back in here.
                offset = rec.holding_potential if rec.clamp_mode == 'vc' else rec.holding_current
                if offset is None:
                    exc = Exception("Holding value unknown for this recording; cannot generate command data.")
                    # Mark this exception so it can be ignored in specific places
                    exc._ignorable_bug_flag = True
                    raise exc
                self._data = (np.array(rec.command_hdf) * scale) + offset

        return self._data
    
    @property
    def shape(self):
        # allow accessing shape without reading all data
        if self._data is None:
            rec = self.recording
            chan = self.channel_id
            if chan == 'primary':
                return rec.primary_hdf.shape
            elif chan == 'command':
                return rec.command_hdf.shape
        else:
            return self._data.shape
        

    
class MiesRecording(PatchClampRecording):
    """A single stimulus / recording made on a single channel.
    """
    def __init__(self, sweep, sweep_id, ad_chan):
        self._sweep = sweep
        self._nwb = sweep._nwb
        self._trace_id = (sweep_id, ad_chan)
        self._inserted_test_pulse = None
        self._nearest_test_pulse = None
        self._hdf_group_name = sweep._channel_keys[ad_chan]['hdf_group_name']
        self._hdf_group = None
        self._da_chan = None
        headstage_id = int(self.hdf_group['electrode_name'][()][0].split('_')[1])
        
        PatchClampRecording.__init__(self, device_type='MultiClamp 700', device_id=headstage_id,
                                     sync_recording=sweep)

        # update metadata
        nb = self._nwb.notebook()[int(self._trace_id[0])][headstage_id]
        self.meta['holding_potential'] = (
            None if nb['V-Clamp Holding Level'] is None
            else nb['V-Clamp Holding Level'] * 1e-3
        )
        self.meta['holding_current'] = (
            None if nb['I-Clamp Holding Level'] is None
            else nb['I-Clamp Holding Level'] * 1e-12
        )   
        self._meta['notebook'] = nb
        if nb['Clamp Mode'] == 0:
            self._meta['clamp_mode'] = 'vc'
        else:
            self._meta['clamp_mode'] = 'ic'
            self._meta['bridge_balance'] = (
                0.0 if nb['Bridge Bal Enable'] == 0.0 or nb['Bridge Bal Value'] is None
                else nb['Bridge Bal Value'] * 1e6
            )
        self._meta['lpf_cutoff'] = nb['LPF Cutoff']
        offset = nb['Pipette Offset']  # sometimes the pipette offset recording can fail??
        self._meta['pipette_offset'] = None if offset is None else offset * 1e-3
        datetime = MiesNwb.igorpro_date(nb['TimeStamp'])
        self.meta['start_time'] = datetime

        self._channels['primary'] = MiesTSeries(self, 'primary')
        self._channels['command'] = MiesTSeries(self, 'command')

    @property
    def stimulus(self):
        stim = self._meta.get('stimulus', None)
        if stim is None:
            stim = MiesStimulus(self)
            self._meta['stimulus'] = stim
        return stim

    def _stim_wave_note(self):
        """Return version and epochs from stim wave note
        """
        notebook = self._meta['notebook']
        sweep_count = int(notebook['Set Sweep Count'])
        wave_note = notebook['Stim Wave Note']
        lines = wave_note.split('\n')
        version = [line for line in lines if line.startswith('Version =')]
        if len(version) == 0:
            version = 0
        else:
            version = float(version[0].rstrip(';').split(' = ')[1])
        epochs = []
        for line in lines:
            if not line.startswith('Sweep = %d;' % sweep_count):
                continue
            epoch = dict([part.split(' = ') for part in line.split(';') if '=' in part])
            epochs.append(epoch)
            
        return version, epochs

    @property
    def hdf_group(self):
        if self._hdf_group is None:
            self._hdf_group = self._nwb.hdf[self._hdf_group_name]
        return self._hdf_group

    @property
    def clamp_mode(self):
        return 'vc' if self.meta['notebook']['Clamp Mode'] == 0 else 'ic'

    @property
    def primary_hdf(self):
        """The raw HDF5 data containing the primary channel recording
        """
        return self.hdf_group['data']        

    @property
    def command_hdf(self):
        """The raw HDF5 data containing the stimulus command 
        """
        return self._nwb.hdf['stimulus/presentation/data_%05d_DA%d/data' % (self._trace_id[0], self.da_chan())]

    @property
    def nearest_test_pulse(self):
        """The test pulse that was acquired nearest to this recording.
        """
        if self.has_inserted_test_pulse:
            return self.inserted_test_pulse
        else:
            if self._nearest_test_pulse is None:
                self._find_nearest_test_pulse()
            return self._nearest_test_pulse

    def _find_nearest_test_pulse(self):
        start = self.start_time
        min_dt = None
        nearest = None
        for entry in self._nwb.test_pulse_entries():
            dt = abs((entry['timestamp'] - start).total_seconds())
            if min_dt is None or dt < min_dt:
                min_dt = dt
                nearest = entry
        if nearest is None:
            return None

        self._nearest_test_pulse = MiesTestPulse(nearest, self)

    @property
    def has_inserted_test_pulse(self):
        return self.meta['notebook']['TP Insert Checkbox'] == 1.0
    
    @property
    def inserted_test_pulse(self):
        """Return the test pulse inserted at the beginning of the recording,
        or None if no pulse was inserted.
        """
        if self._inserted_test_pulse is None:
            if not self.has_inserted_test_pulse:
                return None
            
            # get start/stop indices of the test pulse region
            pulse_dur = self.meta['notebook']['TP Pulse Duration'] / 1000.
            total_dur = pulse_dur / (1.0 - 2. * self.meta['notebook']['TP Baseline Fraction'])
            start = 0
            stop = start + int(total_dur / self['primary'].dt)
            
            tp = PatchClampTestPulse(self, indices=(start, stop))
            
            # Record amplitude as specified by MIES
            if self.clamp_mode == 'vc':
                amp = self.meta['notebook']['TP Amplitude VC'] * 1e-3
            else:
                amp = self.meta['notebook']['TP Amplitude IC'] * 1e-12

            self._inserted_test_pulse = tp
        return self._inserted_test_pulse

    @property
    def baseline_regions(self):
        """A list of (start, stop) time pairs that cover regions of the recording
        the cell is expected to be in a steady (unperturbed) state.
        """
        pri = self['primary']
        regions = []
        # delay onset auto is time from the beginning of the sweep until the end of the test pulse        
        # (if any), including its flanking baseline regions
        start = self.meta['notebook']['Delay onset auto'] / 1000.  # duration of test pulse
        # delay onset user is extra delay time after the test pulse and before any stim can take effect
        dur = self.meta['notebook']['Delay onset user'] / 1000.  # duration of baseline
        if dur > 0:
            regions.append((start, start+dur))
           
        dur = self.meta['notebook']['Delay termination'] / 1000.
        if dur > 0:
            regions.append((pri.t_end-dur, pri.t_end))
            
        return regions

    def da_chan(self):
        """Return the DA channel ID for this recording.
        """
        if self._da_chan is None:
            hdf = self._nwb.hdf['stimulus/presentation']
            stims = [k for k in hdf.keys() if k.startswith('data_%05d_'%self._trace_id[0])]
            for s in stims:
                elec = hdf[s]['electrode_name'][()][0]
                if elec == 'electrode_%d' % self.device_id:
                    self._da_chan = int(s.split('_')[-1][2:])
            if self._da_chan is None:
                raise Exception("Cannot find DA channel for headstage %d" % self.device_id)
        return self._da_chan

    def _descr(self):
        stim = self.stimulus
        stim_name = '' if stim is None else stim.description
        return "%s %s.%s stim=%s" % (PatchClampRecording._descr(self), self._trace_id[0], self.device_id, stim_name)

    def __getstate__(self):
        state = self.__dict__.copy()
        state['_hdf_group'] = None
        return state

    @property
    def aborted(self):
        """Bool indicating whether this recording was aborted early.
        """
        return np.isnan(self.primary_hdf[-1])


class MiesTestPulse(PatchClampTestPulse):
    def __init__(self, entry, rec):
        chan = rec.device_id
        self._nb_entry = {}
        for k,v in entry.items():
            if isinstance(v, np.ndarray):
                self._nb_entry[k] = v[chan]
            else:
                self._nb_entry[k] = v

        clamp_mode = 'vc' if np.isnan(self._nb_entry['TP Baseline Vm']) else 'ic'
        
        PatchClampRecording.__init__(self,
            device_type=rec.device_type, 
            device_id=rec.device_id,
            start_time=entry['timestamp'],
            channels={},
            clamp_mode=clamp_mode
        )

    @property
    def indices(self):
        return None
        
    @property
    def access_resistance(self):
        """The access resistance measured from this test pulse.
        
        Includes the bridge balance resistance if the recording was made in
        current clamp mode.
        """
        if self.clamp_mode == 'vc':
            return self._nb_entry['TP Peak Resistance'] * 1e6
        else:
            return None
        
    @property
    def input_resistance(self):
        """The input resistance measured from this test pulse.
        """
        return self._nb_entry['TP Steady State Resistance'] * 1e6
    
    @property
    def capacitance(self):
        """The capacitance of the cell measured from this test pulse.
        """
        return None

    @property
    def time_constant(self):
        """The membrane time constant measured from this test pulse.
        """
        return None

    @property
    def baseline_potential(self):
        """The potential of the cell membrane measured (or clamped) before
        the onset of the test pulse.
        """
        if self.clamp_mode == 'ic':
            return self._nb_entry['TP Baseline Vm'] * 1e-3
        else:
            return None  # how do we get the holding potential??
 
    @property
    def baseline_current(self):
        """The pipette current measured (or clamped) before the onset of the
        test pulse.
        """
        if self.clamp_mode == 'vc':
            return self._nb_entry['TP Baseline pA'] * 1e-12
        else:
            return None  # how do we get the holding current??
    

class MiesSyncRecording(SyncRecording):
    """Represents one recorded sweep with multiple channels.
    """
    def __init__(self, nwb, sweep_id):
        sweep_id = int(sweep_id)
        self._nwb = nwb
        self._sweep_id = sweep_id
        self._chan_meta = None
        self._traces = None
        self._notebook_entry = None
        self._aborted = None

        # get list of all A/D channels in this sweep
        self._channel_keys = self._nwb._timeseries.get(sweep_id, {})
        self._ad_channels = sorted(list(self._channel_keys.keys()))
        
        devs = OrderedDict()

        for ch in self._ad_channels:
            # there is a very rare/specific acquisition bug that we want to be able to ignore here:
            try:
                rec = self.create_recording(sweep_id, ch)
            except Exception as exc:
                if hasattr(exc, '_ignorable_bug_flag'):
                    print("Warning: ignoring channel %s in %s; could not determine holding value." % (ch, self))
                    continue
                else:
                    raise
            devs[rec.device_id] = rec

        SyncRecording.__init__(self, devs, parent=nwb)
        self._meta['sweep_id'] = sweep_id

    def create_recording(self, sweep_id, ch):
        return MiesRecording(self, sweep_id, ch)
    
    @property
    def key(self):
        return self._sweep_id

    def __repr__(self):
        return "<%s sweep=%d>" % (self.__class__.__name__, self._sweep_id)

    @property
    def parent(self):
        return self._nwb

    @property
    def aborted(self):
        """Bool indicating whether this sync recording was aborted early.
        """
        if self._aborted is None:
            self._aborted = False
            for dev in self.devices:
                rec = self[dev]
                if rec.aborted:
                    self._aborted = True
                    break
        return self._aborted


class MiesStimulus(stimuli.Stimulus):
    """Stimulus that generates its children by parsing a MIES wavenote
    """
    def __init__(self, recording):
        self._recording = recording
        stim_name = recording.hdf_group['stimulus_description'][()][0]
        stimuli.Stimulus.__init__(self, description=stim_name)
        self._items = None

    @property
    def items(self):
        if self._items is None:
            self._items = []
            self._parse_wavenote()
        return tuple(self._items)
    
    def _parse_wavenote(self):
        rec = self._recording
        
        # Add holding offset
        if rec.clamp_mode == 'ic':                
            units = 'A'
            self.append_item(stimuli.Offset(
                start_time=0,
                amplitude=rec.holding_current,
                description="holding current",
                units=units,
            ))
        elif rec.clamp_mode == 'vc':
            units = 'V'
            self.append_item(stimuli.Offset(
                start_time=0,
                amplitude=rec.holding_potential,
                description="holding potential",
                units=units,
            ))
        else:
            units = None
        
        # inserted test pulse?
        if rec.has_inserted_test_pulse:
            self.append_item(rec.inserted_test_pulse.stimulus)

        notebook = rec._meta['notebook']
        
        if 'Stim Wave Note' in notebook:
            # Stim Wave Note format is explained here: 
            # https://alleninstitute.github.io/MIES/file/_m_i_e_s___wave_builder_8ipf.html#_CPPv319WB_GetWaveNoteEntry4wave8variable6string8variable8variable

            # read stimulus structure from notebook
            version, epochs = rec._stim_wave_note()
            assert len(epochs) > 0
            scale = (1e-3 if rec.clamp_mode == 'vc' else 1e-12) * notebook['Stim Scale Factor']
            t = (notebook['Delay onset oodDAQ'] + notebook['Delay onset user'] + notebook['Delay onset auto']) * 1e-3
            
            # if dDAQ is active, add delay from previous channels
            if notebook['Distributed DAQ'] == 1.0:
                ddaq_delay = notebook['Delay distributed DAQ'] * 1e-3
                for dev in rec.parent.devices:
                    rec2 = rec.parent[dev]
                    if rec2 is self._recording:
                        break
                    _, epochs2 = rec2._stim_wave_note()
                    for ep in epochs2:
                        dt = float(ep.get('Duration', 0)) * 1e-3
                        t += dt
                    t += ddaq_delay
            
            for epoch_n,epoch in enumerate(epochs):
                try:
                    if epoch['Epoch'] == 'nan':
                        # Sweep-specific entry; not sure if we need to do anything with this.
                        continue

                    stim_type = epoch.get('Type')
                    duration = float(epoch.get('Duration', 0)) * 1e-3
                    name = "Epoch %d" % int(epoch['Epoch'])
                    if stim_type == 'Square pulse':
                        item = stimuli.SquarePulse(
                            start_time=t, 
                            amplitude=float(epoch['Amplitude']) * scale, 
                            duration=duration, 
                            description=name,
                            units=units,
                        )
                    elif stim_type == 'Pulse Train':
                        assert epoch['Poisson distribution'] == 'False', "Poisson distributed pulse train not supported"
                        assert epoch['Pulse Type'] == 'Square', "Pulse train with %s pulse type not supported"
                        if epoch['Mixed frequency'] == 'True':
                            ptimes = [float(pt) * 1e-3 for pt in epoch['Pulse Train Pulses'].split(',') if pt.strip() != '']
                            item = stimuli.SquarePulseSeries(
                                start_time=t,
                                pulse_times=ptimes,
                                pulse_durations=[float(epoch['Pulse duration']) * 1e-3] * len(ptimes),
                                amplitudes=[float(epoch['Amplitude']) * scale] * len(ptimes),
                                description=name,
                                units=units,
                            )
                        else:
                            item = stimuli.SquarePulseTrain(
                                start_time=t,
                                n_pulses=int(epoch['Number of pulses']),
                                pulse_duration=float(epoch['Pulse duration']) * 1e-3,
                                amplitude=float(epoch['Amplitude']) * scale,
                                interval=float(epoch['Pulse To Pulse Length']) * 1e-3,
                                description=name,
                                units=units,
                            )
                    elif stim_type == 'Sin Wave':
                        # bug in stim wave note version 2: log chirp field is inverted
                        is_chirp = epoch['Log chirp'] == ('False' if version <= 2 else 'True')
                        if is_chirp:
                            assert epoch['FunctionType'] == 'Sin', "Chirp wave function type %s not supported" % epoch['Function type']
                            item = stimuli.Chirp(
                                start_time=t,
                                start_frequency=float(epoch['Frequency']),
                                end_frequency=float(epoch['End frequency']),
                                duration=duration,
                                amplitude=float(epoch['Amplitude']) * scale,
                                phase=0,
                                offset=float(epoch['Offset']) * scale,
                                description=name,
                                units=units,
                            )
                        else:
                            if epoch['FunctionType'] == 'Sin':
                                phase = 0
                            elif epoch['FunctionType'] == 'Cos':
                                phase = np.pi / 2.0
                            else:
                                raise ValueError("Unsupported sine wave function type: %r" % epoch['FunctionType'])
                                
                            item = stimuli.Sine(
                                start_time=t,
                                frequency=float(epoch['Frequency']),
                                duration=duration,
                                amplitude=float(epoch['Amplitude']) * scale,
                                phase=phase,
                                offset=float(epoch['Offset']) * scale,
                                description=name,
                                units=units,
                            )
                    else:
                        print(epoch)
                        print("Warning: unknown stimulus type %s in %s sweep %s" % (stim_type, rec._nwb, rec._trace_id))
                        item = None
                except Exception as exc:
                    print("Warning: error reading stimulus epoch %d in %s sweep %s: %s" % (epoch_n, rec._nwb, rec._trace_id, str(exc)))
                    item = None
                    
                t += duration
                if item is not None:
                    self.append_item(item)

    def save(self):
        data = stimuli.Stimulus.save(self)
        # don't use this class name when saving; just reload as Stimulus.
        data['type'] = 'Stimulus'
        return data